# SIMPLE_JSON

A comprehensive, Unicode-first JSON library for Eiffel with an intuitive API, advanced features, and production-ready quality.

[![Language](https://img.shields.io/badge/language-Eiffel-blue.svg)](https://www.eiffel.org/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Coverage](https://img.shields.io/badge/test_coverage-100%25-brightgreen.svg)]()

## Overview

SIMPLE_JSON provides a complete, high-level API for working with JSON in Eiffel applications. Built on the standard Eiffel JSON library, it offers modern features including JSON Pointer navigation, JSON Patch operations (RFC 6902), JSONPath queries, JSON Schema validation, and comprehensive error handling‚Äîall with full Unicode/UTF-8 support.

**AI-Assisted Development:** Developed interactively using Claude Sonnet 4.5 with Design by Contract principles and 100% test coverage.

## Key Features

### Core Capabilities
- **üåç Unicode First**: STRING_32 throughout - full Unicode/UTF-8 support
- **‚õìÔ∏è Fluent API**: Chainable methods for building JSON structures
- **‚úÖ Type-Safe**: Strong typing with comprehensive DbC contracts
- **üìù Easy Parsing**: Parse JSON with a single method call
- **üî® Easy Building**: Intuitive builder methods
- **üé® Pretty Printing**: Configurable indentation for human readability

### Advanced Features
- **üß≠ JSON Pointer (RFC 6901)**: Path-based navigation (`/users/0/name`)
- **üîß JSON Patch (RFC 6902)**: Standard document modification operations
- **üîç JSONPath Queries**: Flexible queries with wildcards (`$.people[*].name`)
- **‚úì JSON Schema Validation**: Validate documents against schemas
- **üìç Position Tracking**: Line/column information for parse errors
- **üéØ Design by Contract**: Full DbC with preconditions, postconditions, invariants
- **üß™ Well-Tested**: 100% test coverage with 200+ tests

### What Makes This Special

**No Other Eiffel JSON Library Provides:**
- JSON Schema validation - Validate documents against schemas
- JSON Patch (RFC 6902) support
- JSON Pointer (RFC 6901) navigation
- JSONPath queries with wildcards
- Position-aware error tracking
- Fluent API with proper CQS compliance
- 100% STRING_32 public API

## Quick Start

### Installation

1. Clone the repository:
```bash
git clone https://github.com/ljr1981/simple_json.git
```

2. Add to your project's `.ecf` file:
```xml
<library name="simple_json" location="$SIMPLE_JSON/simple_json.ecf"/>
```

3. Set `SIMPLE_JSON` environment variable or use absolute path.

### Basic Parsing

```eiffel
local
    json: SIMPLE_JSON
    value: detachable SIMPLE_JSON_VALUE
do
    create json
    value := json.parse ('{"name": "Alice", "age": 30}')
    
    if attached value and then value.is_object then
        print (value.as_object.string_item ("name"))  -- Alice
        print (value.as_object.integer_item ("age"))  -- 30
    end
end
```

### Building JSON

```eiffel
local
    json: SIMPLE_JSON
    obj: SIMPLE_JSON_OBJECT
do
    create json
    obj := json.new_object
        .put_string ("Bob", "name")
        .put_integer (25, "age")
        .put_boolean (True, "active")
    
    print (obj.to_json_string)
    -- {"name":"Bob","age":25,"active":true}
end
```

## Advanced Features

### JSON Pointer Navigation

Navigate JSON documents using RFC 6901 paths:

```eiffel
local
    json: SIMPLE_JSON
    doc: detachable SIMPLE_JSON_VALUE
    pointer: SIMPLE_JSON_POINTER
    name: detachable SIMPLE_JSON_VALUE
do
    create json
    doc := json.parse ('{
        "users": [
            {"name": "Alice", "age": 30},
            {"name": "Bob", "age": 25}
        ]
    }')
    
    if attached doc then
        create pointer
        
        -- Navigate to first user's name
        name := pointer.get_value (doc, "/users/0/name")
        if attached name and then name.is_string then
            print (name.as_string_32)  -- Alice
        end
    end
end
```

**JSON Pointer features:**
- Path parsing and validation
- Array index handling (0-based)
- Error reporting for invalid paths
- Navigation to parent containers

### JSON Patch Operations

Modify JSON documents using RFC 6902 patch operations:

```eiffel
local
    json: SIMPLE_JSON
    doc: detachable SIMPLE_JSON_VALUE
    patch: SIMPLE_JSON_PATCH
    result: SIMPLE_JSON_PATCH_RESULT
do
    create json
    doc := json.parse ('{"name": "Alice", "age": 30}')
    
    if attached doc as al_doc then
        -- Create patch with fluent API
        create patch.make
        patch
            .add ("/email", json.string_value ("alice@example.com"))
            .replace ("/age", json.integer_value (31))
            .remove ("/name")
            .do_nothing
        
        -- Apply patch atomically
        result := patch.apply (al_doc)
        
        if result.is_success then
            print (result.modified_document.to_json_string)
            -- {"age":31,"email":"alice@example.com"}
        else
            print (result.error_message)
        end
    end
end
```

**Supported operations:**
- `add` - Add or replace value
- `remove` - Remove value
- `replace` - Replace existing value
- `move` - Move value to new location
- `copy` - Copy value to new location
- `test` - Test value equality

**Patch features:**
- Atomic application (all-or-nothing)
- Detailed error messages with operation numbers
- Array operations (insert, append, remove by index)
- Object property operations
- Serialization to/from JSON

### JSONPath Queries

Query JSON documents using intuitive path expressions with wildcards:

```eiffel
local
    json: SIMPLE_JSON
    doc: detachable SIMPLE_JSON_VALUE
do
    create json
    doc := json.parse ('{
        "people": [
            {"name": "Alice", "age": 30},
            {"name": "Bob", "age": 25},
            {"name": "Charlie", "age": 35}
        ]
    }')
    
    if attached doc then
        -- Query single value
        if attached json.query_string (doc, "$.people[0].name") as name then
            print (name)  -- Alice
        end
        
        -- Query with wildcard - get all names
        across json.query_strings (doc, "$.people[*].name") as ic loop
            print (ic.item)  -- Alice, Bob, Charlie
        end
        
        -- Query multiple integers
        across json.query_integers (doc, "$.people[*].age") as ic loop
            print (ic.item.out)  -- 30, 25, 35
        end
    end
end
```

**JSONPath features:**
- Simple dot notation: `$.person.name`
- Nested paths: `$.person.address.street`
- Array indexing: `$.hobbies[0]` (0-based)
- Wildcard queries: `$.people[*].name` (all names from array)
- Type-safe results: `query_string`, `query_integer`, `query_strings`, `query_integers`
- Returns Void/empty for nonexistent paths

### JSON Schema Validation

Validate JSON documents against schemas to ensure data integrity:

```eiffel
local
    json: SIMPLE_JSON
    validator: SIMPLE_JSON_SCHEMA_VALIDATOR
    schema: SIMPLE_JSON_SCHEMA
    doc: detachable SIMPLE_JSON_VALUE
    result: SIMPLE_JSON_SCHEMA_VALIDATION_RESULT
do
    create json
    create validator.make
    
    -- Define schema
    create schema.make_from_string ('{
        "type": "object",
        "properties": {
            "name": {"type": "string", "minLength": 1},
            "age": {"type": "integer", "minimum": 0, "maximum": 150},
            "email": {"type": "string", "pattern": "^[^@]+@[^@]+\\.[^@]+$"}
        },
        "required": ["name", "age"]
    }')
    
    -- Validate document
    doc := json.parse ('{"name": "Alice", "age": 30, "email": "alice@example.com"}')
    
    if attached doc as al_doc then
        result := validator.validate (al_doc, schema)
        
        if result.is_valid then
            print ("Document is valid")
        else
            across result.errors as ic loop
                print (ic.item)  -- Detailed error messages
            end
        end
    end
end
```

**Schema validation features:**
- Type validation: `string`, `number`, `integer`, `boolean`, `object`, `array`, `null`
- String constraints: `minLength`, `maxLength`, `pattern` (regex)
- Number constraints: `minimum`, `maximum`
- Array constraints: `minItems`, `maxItems`, `uniqueItems`
- Object constraints: `properties`, `required`, `additionalProperties`
- Detailed error messages with paths
- Production-ready with comprehensive testing

### Pretty Printing

Format JSON for human readability:

```eiffel
local
    json: SIMPLE_JSON
    person: SIMPLE_JSON_OBJECT
do
    create json
    person := json.new_object
        .put_string ("Eve", "name")
        .put_integer (32, "age")
    
    -- Default 2-space indentation
    print (person.to_pretty_json)
    -- {
    --   "name": "Eve",
    --   "age": 32
    -- }
    
    -- Custom indentation
    print (person.to_pretty_json_with_spaces (4))  -- 4 spaces
    print (person.to_pretty_json_with_tabs)        -- Tabs
    print (person.to_pretty_json_with_indent ("  ")) -- Custom string
end
```

**Features:**
- Configurable indentation (spaces, tabs, custom)
- Proper nesting and formatting
- Unicode characters display correctly
- Valid JSON output (can be re-parsed)
- Compact display for empty structures

### Error Handling

Comprehensive error reporting with position tracking:

```eiffel
local
    json: SIMPLE_JSON
    value: detachable SIMPLE_JSON_VALUE
    error: SIMPLE_JSON_ERROR
do
    create json
    value := json.parse ('{"invalid": }')  -- Syntax error
    
    if value = Void and then json.has_errors then
        across json.last_errors as ic loop
            error := ic
            print ("Error at line " + error.line.out + 
                   ", column " + error.column.out + ": " +
                   error.message)
        end
    end
end
```

## Core Components

### SIMPLE_JSON (Main Facade)

**Parsing:**
- `parse (json_text: STRING_32): detachable SIMPLE_JSON_VALUE`
- `parse_file (file_path: STRING_32): detachable SIMPLE_JSON_VALUE`
- `is_valid_json (json_text: STRING_32): BOOLEAN`

**Building:**
- `new_object: SIMPLE_JSON_OBJECT`
- `new_array: SIMPLE_JSON_ARRAY`
- `string_value`, `integer_value`, `number_value`, `boolean_value`, `null_value`

**JSONPath Queries:**
- `query_string (value, path): detachable STRING_32`
- `query_integer (value, path): INTEGER_64`
- `query_strings (value, path): ARRAYED_LIST[STRING_32]`
- `query_integers (value, path): ARRAYED_LIST[INTEGER_64]`

**Error Handling:**
- `has_errors: BOOLEAN`
- `last_errors: LIST[SIMPLE_JSON_ERROR]`
- `clear_errors`

### SIMPLE_JSON_PATCH

**Creation:**
- `make` - Create empty patch
- `make_from_array` - Create from operation array

**Operations (Fluent API):**
- `add (path, value): SIMPLE_JSON_PATCH`
- `remove (path): SIMPLE_JSON_PATCH`
- `replace (path, value): SIMPLE_JSON_PATCH`
- `move (from, to): SIMPLE_JSON_PATCH`
- `copy_value (from, to): SIMPLE_JSON_PATCH`
- `test (path, value): SIMPLE_JSON_PATCH`

**Application:**
- `apply (document): SIMPLE_JSON_PATCH_RESULT`

**Conversion:**
- `to_json_array: SIMPLE_JSON_ARRAY`
- `to_json_string: STRING_32`

### SIMPLE_JSON_POINTER

**Parsing:**
- `parse_path (path: STRING_32): BOOLEAN`

**Navigation:**
- `get_value (document, path): detachable SIMPLE_JSON_VALUE`
- `navigate_to_parent (document): detachable SIMPLE_JSON_VALUE`
- `last_segment: STRING_32`

**Validation:**
- `is_valid_path (path: STRING_32): BOOLEAN`

### SIMPLE_JSON_PATCH_RESULT

**Status:**
- `is_success: BOOLEAN`
- `is_failure: BOOLEAN`

**Access:**
- `modified_document: detachable SIMPLE_JSON_VALUE`
- `error_message: STRING_32`
- `has_document: BOOLEAN`
- `has_error: BOOLEAN`

### SIMPLE_JSON_SCHEMA

**Creation:**
- `make (schema_value: SIMPLE_JSON_VALUE)`
- `make_from_string (schema_text: STRING_32)`

**Schema Properties:**
- `has_type`, `type_value: STRING_32`
- `has_properties`, `properties: SIMPLE_JSON_OBJECT`
- `has_required`, `required: ARRAYED_LIST[STRING_32]`
- `has_minimum`, `minimum: DOUBLE`
- `has_maximum`, `maximum: DOUBLE`
- `has_min_length`, `min_length: INTEGER`
- `has_max_length`, `max_length: INTEGER`
- `has_pattern`, `pattern: STRING_32`

### SIMPLE_JSON_SCHEMA_VALIDATOR

**Validation:**
- `validate (instance, schema): SIMPLE_JSON_SCHEMA_VALIDATION_RESULT`

### SIMPLE_JSON_SCHEMA_VALIDATION_RESULT

**Status:**
- `is_valid: BOOLEAN`
- `has_errors: BOOLEAN`

**Access:**
- `errors: LINKED_LIST[STRING_32]`
- `error_count: INTEGER`

## Architecture

### Design Patterns

**Type Covariance:**
```eiffel
class SIMPLE_JSON_VALUE
    json_value: JSON_VALUE

class SIMPLE_JSON_OBJECT inherit SIMPLE_JSON_VALUE
    redefine json_value
    json_value: JSON_OBJECT  -- Covariant redefinition
```

**Fluent Builder Pattern:**
```eiffel
obj.put_string ("value1", "key1")
   .put_integer (42, "key2")
   .put_boolean (True, "key3")
```

**Result Objects:**
```eiffel
result := patch.apply (document)
if result.is_success then
    use (result.modified_document)
else
    report (result.error_message)
end
```

### Design by Contract

Full DbC throughout with appropriate contract inheritance:

```eiffel
feature -- Operations
    apply (a_document: SIMPLE_JSON_VALUE): SIMPLE_JSON_PATCH_RESULT
        require else  -- Contract inheritance
            document_not_void: a_document /= Void
            path_not_empty: not path.is_empty
        local
            l_parent: detachable SIMPLE_JSON_VALUE
        do
            -- Verify assumptions with check assertions
            check parent_is_object: l_parent.is_object end
            
            -- Implementation
        ensure then  -- Contract strengthening
            result_not_void: Result /= Void
            success_has_document: Result.is_success implies Result.modified_document /= Void
            failure_has_error: Result.is_failure implies Result.has_error
        end
```

## Performance

SIMPLE_JSON delivers excellent production performance, validated through comprehensive benchmarking:

### Benchmark Results (Finalized Build)

Tested on EiffelStudio with optimizations enabled and DbC contracts disabled for production:

| Operation | Operations/Second | Performance |
|-----------|------------------|-------------|
| **Parse Small Object** | 217,391 | ‚ö° Excellent |
| **Parse Medium Object** | 83,333 | ‚ö° Excellent |
| **Parse Large Array (100 items)** | 3,436 | ‚úÖ Very Good |
| **Key Lookup (Same Key)** | 2,702,702 | ‚ö°‚ö° Outstanding |
| **Key Lookup (Varied Keys)** | 2,873,563 | ‚ö°‚ö° Outstanding |
| **has_key Operations** | 3,448,275 | ‚ö°‚ö° Outstanding |
| **Fluent API (Object Building)** | 1,851,851 | ‚ö° Excellent |
| **Query (Same Path)** | 555,555 | ‚ö° Excellent |
| **Query (Varied Paths)** | 416,666 | ‚ö° Excellent |
| **Pretty Print (Nested)** | 125,000 | ‚úÖ Very Good |

### Key Takeaways

**Production-Ready Performance:**
- ‚úÖ **Millions of operations per second** for object/key operations
- ‚úÖ **Hundreds of thousands of operations per second** for queries and formatting
- ‚úÖ **Thousands of operations per second** for complex parsing

**Optimization Strategy:**
- EiffelStudio's optimizer delivers 25-30x performance improvements automatically
- Current performance exceeds requirements for typical use cases
- Future profiling-based optimization may provide additional gains but is not urgent

**Development vs Production:**
- Workbench mode: ~27x slower due to DbC contract checking (by design)
- Finalized build: Optimal performance with contracts removed
- **Always benchmark in finalized mode for real-world performance assessment**

## Testing

### Test Coverage

The library maintains **100% test coverage** with over 200 tests across multiple test classes:

- **TEST_SIMPLE_JSON** (46 tests) - Core parsing and building
- **TEST_SIMPLE_JSON_PATCH** (46 tests) - JSON Patch operations
- **TEST_PRETTY_PRINTING** (35 tests) - Pretty printing functionality
- **TEST_JSON_PATH_QUERIES** (15 tests) - JSONPath query operations
- **TEST_JSON_SCHEMA_VALIDATION** (30+ tests) - Schema validation
- **TEST_ERROR_TRACKING** - Error position tracking

### Test Organization

Tests are organized by functional area with a shared base class:

```eiffel
class TEST_SIMPLE_JSON_PATCH

inherit
    TEST_SET_BASE  -- Provides enhanced assertions
    
feature -- Tests
    test_apply_add_to_object
        local
            l_patch: SIMPLE_JSON_PATCH
            l_json: SIMPLE_JSON
            l_doc: detachable SIMPLE_JSON_VALUE
        do
            create l_json
            l_doc := l_json.parse ('{"name": "Alice"}')
            create l_patch.make
            
            if attached l_doc as al_doc then
                l_patch.add ("/age", l_json.integer_value (30)).do_nothing
                
                if attached l_patch.apply (al_doc) as l_result then
                    assert_true ("is_success", l_result.is_success)
                end
            end
        end
end
```

### Running Tests

1. Open `simple_json.ecf` in EiffelStudio
2. Select testing target
3. Compile and execute tests
4. All tests should pass ‚úÖ

## Use Cases

### API Integration
```eiffel
-- Parse REST API response
response := http_client.get ("/api/user/profile")
if attached json.parse (response) as user then
    email := user.as_object.string_item ("email")
end
```

### Configuration Management
```eiffel
-- Load configuration with error handling
if attached json.parse_file ("config.json") as config then
    if config.is_object then
        port := config.as_object.integer_item ("port")
        debug_mode := config.as_object.boolean_item ("debug")
    end
else
    -- Handle parse errors with position information
    across json.last_errors as ic loop
        log_error (ic.message + " at line " + ic.line.out)
    end
end
```

### Document Patching
```eiffel
-- Apply configuration updates
create patch.make
patch
    .replace ("/database/host", json.string_value ("new-host"))
    .replace ("/database/port", json.integer_value (5432))
    .add ("/features/beta", json.boolean_value (True))
    .do_nothing

if attached patch.apply (config) as result then
    if result.is_success then
        save_config (result.modified_document.to_pretty_json)
    else
        log_error ("Patch failed: " + result.error_message)
    end
end
```

### Internationalization
```eiffel
-- Full Unicode support
translations := json.new_object
    .put_string ("Welcome", "en")
    .put_string ("Bienvenue", "fr")
    .put_string ("Ê¨¢Ëøé", "zh")
    .put_string ("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å", "ru")
    .put_string ("ŸÖÿ±ÿ≠ÿ®ÿß", "ar")
    .put_string ("üéâ Hello!", "emoji")
```

### Data Extraction with JSONPath
```eiffel
-- Extract specific data from complex JSON
if attached json.parse (api_response) as doc then
    -- Get all product names from array
    across json.query_strings (doc, "$.products[*].name") as ic loop
        add_to_catalog (ic.item)
    end
    
    -- Get all prices for calculations
    across json.query_integers (doc, "$.products[*].price") as ic loop
        calculate_total (ic.item)
    end
end
```

### Input Validation with Schema
```eiffel
-- Validate user input before processing
create schema.make_from_string (user_profile_schema)
if attached json.parse (user_input) as input then
    result := validator.validate (input, schema)
    
    if result.is_valid then
        process_user_profile (input)
    else
        across result.errors as ic loop
            display_validation_error (ic.item)
        end
    end
end
```

## Requirements

- **EiffelStudio**: 19.05 or later (void-safe mode required)
- **Platform**: Windows, macOS, Linux
- **Dependencies**: 
  - Eiffel base library
  - Eiffel encoding library
  - Eiffel JSON library (included with EiffelStudio)

## Design Principles

1. **Simple over complex** - Easy API for common cases, powerful API for advanced cases
2. **Unicode-first** - STRING_32 everywhere, no encoding headaches
3. **Type-safe** - Comprehensive contracts and void-safety
4. **Standards-compliant** - RFC 6901 (Pointer), RFC 6902 (Patch)
5. **CQS-compliant** - Proper Command-Query Separation with `.do_nothing` pattern
6. **Well-tested** - 100% test coverage with DbC catching bugs early

## Project Status

### Completed ‚úÖ

**Core Features:**
- JSON parsing with position tracking
- JSON building with fluent API
- Unicode/UTF-8 support (STRING_32 throughout)
- Type checking and conversions
- Pretty printing (configurable indentation)

**Advanced Features:**
- JSON Pointer (RFC 6901) - Path navigation
- JSON Patch (RFC 6902) - Document modification
  - All 6 operations: add, remove, replace, move, copy, test
  - Atomic application (all-or-nothing)
  - Array and object operations
  - Serialization support
- JSONPath Queries - Flexible path queries with wildcards
  - Single and multiple value queries
  - Array wildcard support (`[*]`)
  - Type-safe result methods
- JSON Schema Validation - Comprehensive schema validation
  - Type validation (string, number, integer, object, array, boolean, null)
  - String constraints (minLength, maxLength, pattern)
  - Number constraints (minimum, maximum)
  - Array constraints (minItems, maxItems, uniqueItems)
  - Object constraints (properties, required, additionalProperties)
  - Detailed error reporting with paths

**Quality:**
- 100% test coverage (200+ tests)
- Full Design by Contract
- Void-safety compliant
- Position-aware error tracking
- **Performance benchmarking** - Production-ready performance validated
  - Millions of ops/sec for object operations
  - Comprehensive benchmark suite
  - 25-30x optimization from finalized build

### Future Enhancements üöÄ

**Nice to Have:**
- [ ] **JSON Merge Patch (RFC 7386)** - Simpler alternative to JSON Patch
- [ ] **Streaming parser** - For very large files (>100MB)
- [ ] **Profile-driven optimizations** - Further performance tuning with profiler
  - Current performance is production-ready
  - Profiling may reveal additional optimization opportunities
  - Not urgent - library is already fast for typical use cases

## Contributing

Contributions welcome! 

1. Fork the repository
2. Create a feature branch
3. Add comprehensive tests (maintain 100% coverage)
4. Include Design by Contract assertions
5. Follow Eiffel coding conventions
6. Submit a pull request

### Coding Standards

- Maintain STRING_32 in public API
- Add preconditions, postconditions, and check assertions
- Use `require else`/`ensure then` for contract inheritance
- Follow CQS with `.do_nothing` for fluent APIs
- Name parameters with `a_`, locals with `l_`, attachment locals with `al_`
- One test class per user-facing API class
- Test all success and failure paths

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Author

**Larry Rix** (ljr1981)
- GitHub: [@ljr1981](https://github.com/ljr1981)
- Email: rix.larry@gmail.com

## Acknowledgments

- Built with [EiffelStudio](https://www.eiffel.com/)
- AI-assisted development using Claude Sonnet 4.5
- Based on the standard Eiffel JSON library
- RFC 6901 (JSON Pointer) and RFC 6902 (JSON Patch) standards

## Support

- **Issues**: [GitHub Issues](https://github.com/ljr1981/simple_json/issues)
- **Discussions**: [GitHub Discussions](https://github.com/ljr1981/simple_json/discussions)
- **Email**: rix.larry@gmail.com

---

**Made with ‚ù§Ô∏è using Eiffel and AI | 100% Test Coverage | RFC-Compliant**