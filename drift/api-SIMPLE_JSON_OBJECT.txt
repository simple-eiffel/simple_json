note
	description: "[
				Simple, high-level wrapper for JSON_OBJECT with fluent API and Unicode support.
				All strings are STRING_32 for proper Unicode/UTF-8 handling.
		
				Model query:
					- model: MML_MAP [STRING_32, detachable SIMPLE_JSON_VALUE] for specification
	]"
	date: "$Date$"
	revision: "$Revision$"
	eis: "name=Documentation", "protocol=URI", "src=file://$(SYSTEM_PATH)/docs/docs/core/simple_json_object.html"

class interface
	SIMPLE_JSON_OBJECT

create 
	make
			-- Initialize with empty JSON object

	make_with_json_object (a_object: JSON_OBJECT)
			-- Initialize with existing JSON object.
			-- Note: a_object is attached - void check redundant.
		ensure
			json_set: json_value = a_object

feature -- Access

	generating_type: TYPE [detachable SIMPLE_JSON_OBJECT]
			-- Type of current object
			-- (type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generating_type_not_void: Result /= Void

	generator: STRING_8
			-- Name of current object's generating class
			-- (base class of the type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generator_not_void: Result /= Void
			generator_not_empty: not Result.is_empty

	json_value: JSON_OBJECT
			-- Underlying JSON object
	
feature -- Measurement

	count: INTEGER_32
			-- Number of key-value pairs

	is_empty: BOOLEAN
			-- Is object empty?
	
feature -- Comparison

	frozen deep_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void
			-- or attached to isomorphic object structures?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			shallow_implies_deep: standard_equal (a, b) implies Result
			both_or_none_void: (a = Void) implies (Result = (b = Void))
			same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))
			symmetric: Result implies deep_equal (b, a)

	frozen equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached
			-- to objects considered equal?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.is_equal (b))

	frozen is_deep_equal alias "≡≡≡" (other: SIMPLE_JSON_OBJECT): BOOLEAN
			-- Are `Current` and `other` attached to isomorphic object structures?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			shallow_implies_deep: standard_is_equal (other) implies Result
			same_type: Result implies same_type (other)
			symmetric: Result implies other.is_deep_equal (Current)

	is_equal (other: SIMPLE_JSON_OBJECT): BOOLEAN
			-- Is `other` attached to an object considered
			-- equal to current object?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			symmetric: Result implies other ~ Current
			consistent: standard_is_equal (other) implies Result

	frozen standard_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached to
			-- field-by-field identical objects of the same type?
			-- Always uses default object comparison criterion.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.standard_is_equal (b))

	frozen standard_is_equal alias "≜" (other: SIMPLE_JSON_OBJECT): BOOLEAN
			-- Is `other` attached to an object of the same type
			-- as current object, and field-by-field identical to it?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			same_type: Result implies same_type (other)
			symmetric: Result implies other.standard_is_equal (Current)
	
feature -- Status report

	conforms_to (other: ANY): BOOLEAN
			-- Does type of current object conform to type
			-- of `other` (as per Eiffel: The Language, chapter 13)?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void

	has_key (a_key: STRING_32): BOOLEAN
			-- Does object have key?
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	same_type (other: ANY): BOOLEAN
			-- Is type of current object identical to type of `other`?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			definition: Result = (conforms_to (other) and other.conforms_to (Current))
	
feature -- Removal

	remove (a_key: STRING_32)
			-- Remove key-value pair
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			key_removed: not has_key (a_key)
			count_decreased: count <= old count

	wipe_out
			-- Remove all key-value pairs
		ensure
			empty: is_empty
			count_zero: count = 0
	
feature -- Conversion

	representation: STRING_32
			-- Synonym for to_json_string
			-- (from SIMPLE_JSON_VALUE)

	to_json_string: STRING_32
			-- Convert to JSON string representation (STRING_32)
			-- (from SIMPLE_JSON_VALUE)
	
feature -- Duplication

	copy (other: SIMPLE_JSON_OBJECT)
			-- Update current object using fields of object attached
			-- to `other`, so as to yield equal objects.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_equal: Current ~ other

	frozen deep_copy (other: SIMPLE_JSON_OBJECT)
			-- Effect equivalent to that of:
			--		`copy` (`other` . `deep_twin`)
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			deep_equal: deep_equal (Current, other)

	frozen deep_twin: SIMPLE_JSON_OBJECT
			-- New object structure recursively duplicated from Current.
			-- (from ANY)
		ensure -- from ANY
			deep_twin_not_void: Result /= Void
			deep_equal: deep_equal (Current, Result)

	frozen standard_copy (other: SIMPLE_JSON_OBJECT)
			-- Copy every field of `other` onto corresponding field
			-- of current object.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_standard_equal: standard_is_equal (other)

	frozen standard_twin: SIMPLE_JSON_OBJECT
			-- New object field-by-field identical to `other`.
			-- Always uses default copying semantics.
			-- (from ANY)
		ensure -- from ANY
			standard_twin_not_void: Result /= Void
			equal: standard_equal (Result, Current)

	frozen twin: SIMPLE_JSON_OBJECT
			-- New object equal to `Current`
			-- `twin` calls `copy`; to change copying/twinning semantics, redefine `copy`.
			-- (from ANY)
		ensure -- from ANY
			twin_not_void: Result /= Void
			is_equal: Result ~ Current
	
feature -- Basic operations

	frozen default: detachable SIMPLE_JSON_OBJECT
			-- Default value of object's type
			-- (from ANY)

	frozen default_pointer: POINTER
			-- Default value of type `POINTER`
			-- (Avoid the need to write `p`.`default` for
			-- some `p` of type `POINTER`.)
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	default_rescue
			-- Process exception for routines with no Rescue clause.
			-- (Default: do nothing.)
			-- (from ANY)

	frozen do_nothing
			-- Execute a null action.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
	
feature -- Access (Unicode keys)

	array_item (a_key: STRING_32): detachable SIMPLE_JSON_ARRAY
			-- Get array value for key (returns Void if not an array)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	boolean_item (a_key: STRING_32): BOOLEAN
			-- Get boolean value for key (returns False if not found or not a boolean)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	decimal_item (a_key: STRING_32): detachable SIMPLE_DECIMAL
			-- Get decimal value for key (returns Void if not found or not a number).
			-- Use for precise decimal arithmetic without floating-point errors.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	integer_item (a_key: STRING_32): INTEGER_64
			-- Get integer value for key (returns 0 if not found or not a number)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	item (a_key: STRING_32): detachable SIMPLE_JSON_VALUE
			-- Get value for key (returns Void if key doesn't exist)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	object_item (a_key: STRING_32): detachable SIMPLE_JSON_OBJECT
			-- Get object value for key (returns Void if not an object)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	real_item (a_key: STRING_32): REAL_64
			-- Get real value for key (returns 0.0 if not found or not a number)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	string_item (a_key: STRING_32): detachable STRING_32
			-- Get string value for key (returns Void if not a string)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
	
feature -- Access (convenience - F4 friction fix)

	integer_32_item (a_key: STRING_32): INTEGER_32
			-- Get integer value for key as INTEGER_32 (returns 0 if not found or not a number).
			-- Convenience to avoid `.to_integer_32` after every `integer_item` call.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	natural_32_item (a_key: STRING_32): NATURAL_32
			-- Get natural value for key as NATURAL_32 (returns 0 if not found or not a number).
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
	
feature -- Access (optional - F5 friction fix)

	optional_boolean (a_key: STRING_32; a_default: BOOLEAN): BOOLEAN
			-- Get boolean value if key exists, `a_default` otherwise.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	optional_integer (a_key: STRING_32; a_default: INTEGER_64): INTEGER_64
			-- Get integer value if key exists, `a_default` otherwise.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length

	optional_string (a_key: STRING_32): detachable STRING_32
			-- Get string value if key exists, Void otherwise.
			-- Same as string_item but name clarifies intent for optional fields.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
	
feature -- Array access

	array_value: SIMPLE_JSON_ARRAY
			-- Synonym for as_array
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_array: is_array

	as_array: SIMPLE_JSON_ARRAY
			-- Get value as array
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_array: is_array
	
feature -- Boolean access

	as_boolean: BOOLEAN
			-- Get value as boolean
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_boolean: is_boolean

	boolean_value: BOOLEAN
			-- Synonym for as_boolean
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_boolean: is_boolean
	
feature -- Constants

	Max_reasonable_key_length: INTEGER_32 = 1024
			-- Maximum reasonable length for JSON keys (defense against abuse)

	Max_reasonable_object_size: INTEGER_32 = 100000
			-- Maximum reasonable number of properties (defense against memory exhaustion)

	Max_reasonable_string_length: INTEGER_32 = 10000000
			-- Maximum reasonable length for JSON string values (10MB, defense against DoS)
	
feature -- Decimal access

	as_decimal: SIMPLE_DECIMAL
			-- Get value as SIMPLE_DECIMAL for precise arithmetic.
			-- Preserves exact precision from JSON source.
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number
		ensure -- from SIMPLE_JSON_VALUE
			result_attached: Result /= Void

	decimal_value: SIMPLE_DECIMAL
			-- Synonym for as_decimal
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number
	
feature -- Element change (Fluent API)

	put_array (a_value: SIMPLE_JSON_ARRAY; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add array value with key (fluent).
			-- Note: a_value is attached - void check redundant.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			is_array: attached item (a_key) as l_v implies l_v.is_array
			nested_count: attached array_item (a_key) as l_nested implies l_nested.count = a_value.count

	put_boolean (a_value: BOOLEAN; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add boolean value with key (fluent)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			value_stored: boolean_item (a_key) = a_value

	put_decimal (a_value: SIMPLE_DECIMAL; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add decimal value with key (fluent).
			-- Use for precise decimal values without floating-point errors.
			-- The decimal's exact string representation is preserved in JSON.
			-- Note: a_value is attached - void check redundant.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)

	put_integer (a_value: INTEGER_64; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add integer value with key (fluent)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			value_stored: integer_item (a_key) = a_value

	put_null (a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add null value with key (fluent)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			is_null: attached item (a_key) as l_v implies l_v.is_null

	put_object (a_value: SIMPLE_JSON_OBJECT; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add object value with key (fluent).
			-- Note: a_value is attached - void check redundant.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			is_object: attached item (a_key) as l_v implies l_v.is_object
			nested_count: attached object_item (a_key) as l_nested implies l_nested.count = a_value.count

	put_real (a_value: REAL_64; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add real value with key (fluent)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)

	put_string (a_value: STRING_32; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add string value with key (fluent)
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
			value_reasonable_length: a_value.count <= Max_reasonable_string_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
			value_stored: attached string_item (a_key) as l_stored implies l_stored.same_string (a_value)

	put_value (a_value: SIMPLE_JSON_VALUE; a_key: STRING_32): SIMPLE_JSON_OBJECT
			-- Add any JSON value with key (fluent).
			-- Note: a_value is attached - void check redundant.
		require
			key_not_empty: not a_key.is_empty
			key_reasonable_length: a_key.count <= Max_reasonable_key_length
		ensure
			result_is_current: Result = Current
			key_exists: has_key (a_key)
	
feature -- Iteration

	keys: ARRAY [STRING_32]
			-- Array of all keys (as STRING_32)
	
feature -- Number access

	as_integer: INTEGER_64
			-- Get value as integer
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number

	as_natural: NATURAL_64
			-- Get value as natural
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number

	as_real: REAL_64
			-- Get value as double
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number

	integer_value: INTEGER_64
			-- Synonym for as_integer
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number

	real_value: REAL_64
			-- Synonym for as_real
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_number: is_number
	
feature -- Object access

	as_object: SIMPLE_JSON_OBJECT
			-- Get value as object
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_object: is_object

	object_value: SIMPLE_JSON_OBJECT
			-- Synonym for as_object
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_object: is_object
	
feature -- Output

	as_json: STRING_8
			-- JSON string representation (STRING_8)
			-- (from SIMPLE_JSON_VALUE)
		ensure -- from SIMPLE_JSON_VALUE
			result_attached: Result /= Void

	as_json_32: STRING_32
			-- JSON string representation (STRING_32)
			-- (from SIMPLE_JSON_VALUE)
		ensure -- from SIMPLE_JSON_VALUE
			result_attached: Result /= Void

	Io: STD_FILES
			-- Handle to standard file setup
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			io_not_void: Result /= Void

	out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			out_not_void: Result /= Void

	print (o: detachable ANY)
			-- Write terse external representation of `o`
			-- on standard output.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	frozen tagged_out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			tagged_out_not_void: Result /= Void
	
feature -- Platform

	Operating_environment: OPERATING_ENVIRONMENT
			-- Objects available from the operating system
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			operating_environment_not_void: Result /= Void
	
feature -- Pretty Printing

	to_pretty_json: STRING_32
			-- Convert to pretty-printed JSON with 2-space indentation
			-- (from SIMPLE_JSON_VALUE)

	to_pretty_json_with_indent (a_indent: STRING_32): STRING_32
			-- Convert to pretty-printed JSON with custom indentation
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			indent_not_void: a_indent /= Void
			indent_not_empty: not a_indent.is_empty

	to_pretty_json_with_spaces (a_count: INTEGER_32): STRING_32
			-- Convert to pretty-printed JSON with specified number of spaces
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			positive_count: a_count > 0
			reasonable_count: a_count <= 8

	to_pretty_json_with_tabs: STRING_32
			-- Convert to pretty-printed JSON with tab indentation
			-- (from SIMPLE_JSON_VALUE)
	
feature -- Status report (multiple keys - F3 friction fix)

	has_all_keys (a_keys: ARRAY [STRING_32]): BOOLEAN
			-- Does object have all specified keys?
			-- Note: a_keys is attached - void check redundant.
		ensure
			definition: Result = across
					a_keys as k
				all
					has_key (k)
				end

	has_any_key (a_keys: ARRAY [STRING_32]): BOOLEAN
			-- Does object have at least one of the specified keys?
			-- Note: a_keys is attached - void check redundant.
		ensure
			definition: Result = across
					a_keys as k
				some
					has_key (k)
				end

	missing_keys (a_keys: ARRAY [STRING_32]): ARRAYED_LIST [STRING_32]
			-- Which of the specified keys are missing?
			-- Note: a_keys is attached - void check redundant.
		ensure
			no_void_elements: across
					Result as ic_r
				all
					ic_r /= Void
				end
			all_missing: across
					Result as ic_r
				all
					not has_key (ic_r)
				end
			none_extra: across
					a_keys as ic_a
				all
					has_key (ic_a) or Result.has (ic_a)
				end
	
feature -- String access (STRING_32 only)

	as_string_32: STRING_32
			-- Get value as STRING_32 (Unicode)
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_string: is_string

	string_value: STRING_32
			-- Synonym for as_string_32
			-- (from SIMPLE_JSON_VALUE)
		require -- from SIMPLE_JSON_VALUE
			is_string: is_string
	
feature -- Type checking

	is_array: BOOLEAN
			-- Is this an array value?
			-- (from SIMPLE_JSON_VALUE)

	is_boolean: BOOLEAN
			-- Is this a boolean value?
			-- (from SIMPLE_JSON_VALUE)

	is_integer: BOOLEAN
			-- Is this an integer number value?
			-- (from SIMPLE_JSON_VALUE)

	is_null: BOOLEAN
			-- Is this a null value?
			-- (from SIMPLE_JSON_VALUE)

	is_number: BOOLEAN
			-- Is this a number value?
			-- (from SIMPLE_JSON_VALUE)

	is_object: BOOLEAN
			-- Is this an object value?
			-- (from SIMPLE_JSON_VALUE)

	is_string: BOOLEAN
			-- Is this a string value?
			-- (from SIMPLE_JSON_VALUE)
	
invariant
	json_value_is_object: attached {JSON_OBJECT} json_value
	count_non_negative: count >= 0
	empty_definition: is_empty = (count = 0)
	keys_match_count: keys.count = count
	no_void_keys: across
			keys as ic_key
		all
			ic_key /= Void
		end
	no_empty_keys: across
			keys as ic_key
		all
			not ic_key.is_empty
		end
	every_key_exists: across
			keys as ic_key
		all
			has_key (ic_key)
		end
	every_key_has_value: across
			keys as ic_key
		all
			item (ic_key) /= Void
		end

		-- from SIMPLE_JSON_VALUE
	json_value_attached: json_value /= Void
	valid_json_type: is_string or is_number or is_boolean or is_null or is_object or is_array
	string_excludes_others: is_string implies (not is_number and not is_boolean and not is_null and not is_object and not is_array)
	number_excludes_others: is_number implies (not is_string and not is_boolean and not is_null and not is_object and not is_array)
	boolean_excludes_others: is_boolean implies (not is_string and not is_number and not is_null and not is_object and not is_array)
	null_excludes_others: is_null implies (not is_string and not is_number and not is_boolean and not is_object and not is_array)
	object_excludes_others: is_object implies (not is_string and not is_number and not is_boolean and not is_null and not is_array)
	array_excludes_others: is_array implies (not is_string and not is_number and not is_boolean and not is_null and not is_object)
	string_type_accurate: is_string = (attached {JSON_STRING} json_value)
	number_type_accurate: is_number = json_value.is_number
	boolean_type_accurate: is_boolean = (attached {JSON_BOOLEAN} json_value)
	null_type_accurate: is_null = json_value.is_null
	object_type_accurate: is_object = json_value.Is_object
	array_type_accurate: is_array = json_value.is_array

		-- from ANY
	reflexive_equality: standard_is_equal (Current)
	reflexive_conformance: conforms_to (Current)

end -- class SIMPLE_JSON_OBJECT

